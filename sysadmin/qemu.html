
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>QEmu-KVM notes &#8212; Generic Config</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Qubes OS setup" href="qubes-os.html" />
    <link rel="prev" title="Configure a server to handle network boot (PXE)" href="pxe-boot-server.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="qubes-os.html" title="Qubes OS setup"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pxe-boot-server.html" title="Configure a server to handle network boot (PXE)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Generic Config</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Some notes and tips&amp;tricks about system administration</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="qemu-kvm-notes">
<h1>QEmu-KVM notes<a class="headerlink" href="#qemu-kvm-notes" title="Permalink to this headline">¶</a></h1>
<p>This document contains some useful command lines to use QEmu to work with
virtual images.</p>
<div class="section" id="simple-qemu-invocation-commands">
<h2>Simple QEmu invocation commands<a class="headerlink" href="#simple-qemu-invocation-commands" title="Permalink to this headline">¶</a></h2>
<p>The most simple QEmu usage consists in running a disk image or a liveCD/liveUSB
in a virtual machine, with a NAT network.  Here are some commands:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run a LiveCD</span>
qemu-system-x86_64 -cdrom livecd.iso -boot d

<span class="c1"># Run a disk image with KVM acceleration, 1GB memory and 4 cores</span>
qemu-system-x86_64 -enable-kvm -m 1024M -cpu host -smp <span class="nv">cores</span><span class="o">=</span><span class="m">4</span> disk-image.img

<span class="c1"># Run a kernel with a cow images and output its console on the current tty</span>
qemu-system-x86_64 -nographic <span class="se">\</span>
    -drive <span class="nv">file</span><span class="o">=</span>image.qcow2,if<span class="o">=</span>virtio <span class="se">\</span>
    -kernel vmlinuz -initrd initrd.img <span class="se">\</span>
    -append <span class="s2">&quot;root=/dev/vda1 console=ttyS0,16550A earlyprint=serial,ttyS0,16550A&quot;</span>

<span class="c1"># Boot in UEFI mode with a Tianocore UEFI firmware (from https://github.com/tianocore/edk2)</span>
qemu-system-x86_64 -bios /usr/share/ovmf/ovmf_x64.bin ...

<span class="c1"># Run a kernel with an initrd (made with &quot;find . -print | cpio -o -Hcrc | gzip &gt; ../initrd.img&quot;</span>
<span class="c1"># for example) on a KVM CPU, maybe booted from the network</span>
<span class="c1"># (source https://lkml.org/lkml/2014/9/2/11)</span>
<span class="c1"># By the way, to extract initrd images: &quot;cat ../initrd.img | cpio -id&quot;</span>
qemu-system-x86_64 -enable-kvm -cpu kvm64 -m <span class="m">320</span> -smp <span class="m">2</span> <span class="se">\</span>
    -kernel vmlinux -initrd initrd.img <span class="se">\</span>
    -net nic,vlan<span class="o">=</span><span class="m">1</span>,model<span class="o">=</span>e1000 -net user,vlan<span class="o">=</span><span class="m">1</span> -boot <span class="nv">order</span><span class="o">=</span>nc <span class="se">\</span>
    -no-reboot -watchdog i6300esb -rtc <span class="nv">base</span><span class="o">=</span>localtime <span class="se">\</span>
    -serial stdio -display none -monitor null <span class="se">\</span>
    -append <span class="s2">&quot; \</span>
<span class="s2">        earlyprintk=ttyS0,115200 console=ttyS0,115200 console=tty0 \</span>
<span class="s2">        panic=-1 oops=panic vga=normal \</span>
<span class="s2">        load_ramdisk=2 prompt_ramdisk=0 root=/dev/ram0 rw&quot;</span>

<span class="c1"># Run an ARM kernel in a Versatile QEmu machine with a Raspberry-Pi-like CPU</span>
<span class="c1"># (source http://web.archive.org/web/20150512213356/http://xecdesign.com/qemu-emulating-raspberry-pi-the-easy-way/)</span>
qemu-system-arm <span class="se">\</span>
    -kernel kernel-qemu <span class="se">\</span>
    -cpu arm1176 -m <span class="m">256</span> <span class="se">\</span>
    -machine versatilepb <span class="se">\</span>
    -chardev socket,id<span class="o">=</span>monitor,path<span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/monitor.sock,server,nowait <span class="se">\</span>
    -monitor chardev:monitor <span class="se">\</span>
    -hda rpiarch.qcow2 <span class="se">\</span>
    -net nic -net user,hostname<span class="o">=</span>raspberrypi <span class="se">\</span>
    -serial pty -nographic -no-reboot <span class="se">\</span>
    -append <span class="s2">&quot;root=/dev/sda rw rootfstype=ext4 panic=0 earlyprint=serial,ttyAMA0,38400 loglevel=7 console=ttyAMA0,38400 kgdboc=ttyAMA0,38400&quot;</span>

<span class="c1"># Run a MIPS kernel</span>
<span class="c1"># (source https://doar-e.github.io/blog/2014/10/11/taiming-a-wild-nanomite-protected-mips-binary-with-symbolic-execution-no-such-crackme/)</span>
qemu-system-mipsel -M malta -kernel vmlinux-malta -hda root.qcow2 <span class="se">\</span>
    -nographic -append <span class="s2">&quot;root=/dev/sda1 console=tty0&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="networking">
<h2>Networking<a class="headerlink" href="#networking" title="Permalink to this headline">¶</a></h2>
<p>It is possible to run a virtual machine which only exposes some TCP ports
through local TCP redirections using the “user network” with options:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Redirect local host 2222 (on host) to guest SSH port (legacy parameters)</span>
-net nic -net user,hostname<span class="o">=</span>myvm -redir tcp:2222::22

<span class="c1"># Or, more complex (recent parameters)</span>
-net nic,model<span class="o">=</span>virtio,macaddr<span class="o">=</span><span class="m">52</span>:54:00:12:34:56 -net user,hostfwd<span class="o">=</span>tcp:127.0.0.1:2222-:22
</pre></div>
</div>
<p>To run a virtual machine with a tap interface which is bridged to a <code class="docutils literal notranslate"><span class="pre">br0</span></code>
interface (created for example with <code class="docutils literal notranslate"><span class="pre">brctl</span> <span class="pre">addbr</span> <span class="pre">br0</span></code>), here are commands
which can be used:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Old command: tunctl -u &quot;$(id -nu)&quot; -t tap_vm</span>
sudo ip tuntap add dev tap_vm mode tap user <span class="s2">&quot;</span><span class="k">$(</span>id -nu<span class="k">)</span><span class="s2">&quot;</span>
<span class="nb">trap</span> <span class="s2">&quot;ip tuntap del dev tap_vm mode tap&quot;</span> EXIT HUP INT QUIT TERM
sudo ip link <span class="nb">set</span> tap_vm up promisc on
sudo brctl addif br0 tap_vm
</pre></div>
</div>
<p>The result of these commands can be checked with <code class="docutils literal notranslate"><span class="pre">ip</span></code> and <code class="docutils literal notranslate"><span class="pre">brctl</span></code> commands:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ ip link show tap_vm
<span class="m">4</span>: tap_vm: &lt;NO-CARRIER,BROADCAST,MULTICAST,PROMISC,UP&gt; mtu <span class="m">1500</span> qdisc fq_codel
master br0 state DOWN mode DEFAULT group default qlen <span class="m">500</span>
link/ether 3a:d9:20:17:d3:c0 brd ff:ff:ff:ff:ff:ff

$ brctl show br0
bridge name bridge id               STP enabled     interfaces
br0         <span class="m">8000</span>.be2f28151bed       no              tap_vm
</pre></div>
</div>
<p>To add this new virtual interface to a QEmu virtual machine, these command-line
arguments can be used:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>-net nic,macaddr<span class="o">=</span><span class="nv">$MAC</span> -net tap,ifname<span class="o">=</span>tap_vm,script<span class="o">=</span>no,downscript<span class="o">=</span>no
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">$MAC</span></code> is the MAC address to use, for example generated with:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nv">MAC</span><span class="o">=</span><span class="k">$(</span><span class="nb">printf</span> <span class="s1">&#39;52:54:%02x:%02x:%02x:%02x&#39;</span> <span class="k">$((</span>RANDOM <span class="o">&amp;</span> <span class="m">0</span>xff<span class="k">))</span> <span class="k">$((</span>RANDOM <span class="o">&amp;</span> <span class="m">0</span>xff<span class="k">))</span> <span class="se">\</span>
   <span class="k">$((</span>RANDOM <span class="o">&amp;</span> <span class="m">0</span>xff<span class="k">))</span> <span class="k">$((</span>RANDOM <span class="o">&amp;</span> <span class="m">0</span>xff<span class="k">)))</span>
</pre></div>
</div>
<p>Another possible choice of arguments is:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>-device virtio-net,netdev<span class="o">=</span>tap,mac<span class="o">=</span><span class="nv">$MAC</span>
-netdev <span class="nv">type</span><span class="o">=</span>tap,ifname<span class="o">=</span>tap_vm,script<span class="o">=</span>no,downscript<span class="o">=</span>no,id<span class="o">=</span>tap
</pre></div>
</div>
</div>
<div class="section" id="qcow2-format-and-virtual-disk-usage">
<h2>QCow2 format and virtual disk usage<a class="headerlink" href="#qcow2-format-and-virtual-disk-usage" title="Permalink to this headline">¶</a></h2>
<p>QEmu can use the QCow2 format for disks to efficiently store the data of virtual
disks (documentation: <a class="reference external" href="https://en.wikibooks.org/wiki/QEMU/Images">https://en.wikibooks.org/wiki/QEMU/Images</a>).</p>
<p>To create a 10G disk image, the following command can be used:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>qemu-img create -f qcow2 virtual_disk.qcow2 10G
</pre></div>
</div>
<p>The resulting file weights 193KB and will expand once the disk image begins to
be filled with data.</p>
<p>The QCow2 images can not be directly mounted and an indirection layer needs to
be used to use such disks in a live system.  For example a kernel module can be
used, by issuing the following commands as root:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>modprobe nbd <span class="nv">max_part</span><span class="o">=</span><span class="m">8</span>
qemu-nbd -c /dev/nbd0 virtual_disk.qcow2
mount /dev/nbd0p1 /mnt
...
umount /mnt
qemu-nbd -d /dev/nbd0
</pre></div>
</div>
<p>This can be used to use the files stored on the virtual disk.  Another use when
the virtual disk is the root partition of a systemd-based system is to be able
to launch the system in a container, with:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>systemd-nspawn -D /mnt
</pre></div>
</div>
<p>In order to mount a journalised filesystem read-only, the option <code class="docutils literal notranslate"><span class="pre">norecovery</span></code>
can be required (for example on ext4fs):</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>mount -o ro,norecovery /dev/nbd0p1 /mnt
</pre></div>
</div>
</div>
<div class="section" id="nfs-configuration">
<h2>NFS configuration<a class="headerlink" href="#nfs-configuration" title="Permalink to this headline">¶</a></h2>
<p>To share files between a virtual machine and the host, it is possible to set
up and Network Filesystem (NFS) share.  Here is a sample configuration to share
<code class="docutils literal notranslate"><span class="pre">/srv/nfs/ro</span></code> read-only and <code class="docutils literal notranslate"><span class="pre">/srv/nfs/user-rw</span></code> read-write, with writing
creating files for user 1000 group 100 on the host.  The virtual machine is
supposed to get an IP address in the 10.0.0.0/24 range, with the host having the
address 10.0.0.1.</p>
<p>On the host:</p>
<ul class="simple">
<li><p>Install <code class="docutils literal notranslate"><span class="pre">nfs-utils</span></code> package or something similar.</p></li>
<li><p>Make sure <code class="docutils literal notranslate"><span class="pre">/srv/nfs</span></code> is accessible to everyone (if this directory is
chmod-ed <code class="docutils literal notranslate"><span class="pre">o-x</span></code>, NFS denies the access to the clients).</p></li>
<li><p>Add in <code class="docutils literal notranslate"><span class="pre">/etc/exports</span></code>:</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/srv/nfs/ro 10.0.0.0/24(ro,sync)
/srv/nfs/user-rw 10.0.0.0/24(rw,no_subtree_check,sync,anonuid=1000,anongid=100)
</pre></div>
</div>
<ul class="simple">
<li><p>Reload the currently exported entries:</p></li>
</ul>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>exportfs -arv
</pre></div>
</div>
<ul class="simple">
<li><p>Start the NFS services:</p></li>
</ul>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>systemctl start rpcbind.service nfs-server.service
</pre></div>
</div>
<ul class="simple">
<li><p>Open the ports in the firewall configuration:</p></li>
</ul>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>iptables -A INPUT -i br0 -p tcp -m multiport --dports <span class="m">111</span>,2049,20048,49367 -j ACCEPT
iptables -A INPUT -i br0 -p udp -m multiport --dports <span class="m">111</span>,745,2049,20048,57797 -j ACCEPT
</pre></div>
</div>
<p>On the virtual machine:</p>
<ul class="simple">
<li><p>Install <code class="docutils literal notranslate"><span class="pre">nfs-utils</span></code> package or something similar.</p></li>
<li><p>Check that the exported directory are accessible:</p></li>
</ul>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>showmount -e <span class="m">10</span>.0.0.1
</pre></div>
</div>
<ul class="simple">
<li><p>Mount the directories by hand:</p></li>
</ul>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>mount -t nfs <span class="m">10</span>.0.0.1:/srv/nfs/ro /mnt/ro -o ro
mount -t nfs <span class="m">10</span>.0.0.1:/srv/nfs/user-rw /mnt/rw
</pre></div>
</div>
<ul class="simple">
<li><p>Here is the <code class="docutils literal notranslate"><span class="pre">/etc/fstab</span></code> configuration to automatically mount:</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>10.0.0.1:/srv/nfs/ro /mnt/ro nfs auto,ro,_netdev 0 0
10.0.0.1:/srv/nfs/user-rw /mnt/rw nfs auto,rw,_netdev 0 0
</pre></div>
</div>
</div>
<div class="section" id="p-shared-directory">
<h2>9p shared directory<a class="headerlink" href="#p-shared-directory" title="Permalink to this headline">¶</a></h2>
<p>Another way of sharing files between a guest and the host which is simpler than
NFS in its configuration is 9p.</p>
<p>This QEmu parameter shares the content of <code class="docutils literal notranslate"><span class="pre">/var/vmsh</span></code> on the host with the
guest:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>-virtfs local,id<span class="o">=</span>fs0,mount_tag<span class="o">=</span>vmsh,security_model<span class="o">=</span>none,path<span class="o">=</span>/var/vmsh
</pre></div>
</div>
<p>or:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>-fsdev local,id<span class="o">=</span>fs0,security_model<span class="o">=</span>none,path<span class="o">=</span>/var/vmsh
-device virtio-9p-pci,fsdev<span class="o">=</span>fs0,mount_tag<span class="o">=</span>vmsh
</pre></div>
</div>
<p>On the guest, <code class="docutils literal notranslate"><span class="pre">/etc/fstab</span></code> may contain the following line to mount the shared
directory on <code class="docutils literal notranslate"><span class="pre">/mnt/vmsh</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>vmsh /mnt/vmsh 9p auto,trans=virtio,version=9p2000.L,_netdev 0 0
</pre></div>
</div>
</div>
<div class="section" id="interaction-based-on-unix-sockets">
<h2>Interaction based on Unix sockets<a class="headerlink" href="#interaction-based-on-unix-sockets" title="Permalink to this headline">¶</a></h2>
<p>QEmu virtual machines are usually used either in graphical mode, with a QEmu
windown, or in console mode (<code class="docutils literal notranslate"><span class="pre">-nographic</span></code> option), with a serial console
redirected to the standard input/output. A third alternative consists in using
Unix sockets to communicate with the guest. This can be achieved with two QEmu
options:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>-monitor unix:monitor.sock,server,nowait
-serial unix:console.sock,server,nowait
</pre></div>
</div>
<p>If the guest machine runs Linux, the virtual serial port will be available
through device <code class="docutils literal notranslate"><span class="pre">ttyS0</span></code>.  It can be used as a console with early kernel
messages with these kernel command line parameters:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nv">console</span><span class="o">=</span>ttyS0,38400n8 <span class="nv">earlyprint</span><span class="o">=</span>serial,ttyS0,38400n8
</pre></div>
</div>
<p>If the guest machine runs systemd, it is possible to automatically spawn a
login shell on the serial port with the following command:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>systemctl <span class="nb">enable</span> serial-getty@ttyS0.service
</pre></div>
</div>
<p>Then it is possible to:</p>
<ul class="simple">
<li><p>connect to QEmu monitor console for example with:</p></li>
</ul>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use cfmakeraw to make TAB work and isig=1 to allow using Ctrl+C</span>
socat STDIO,cfmakeraw,isig<span class="o">=</span><span class="m">1</span> UNIX:monitor.sock

<span class="c1"># socat&lt;1.7.3.0 does not support cfmakeraw. Use raw instead</span>
socat STDIO,raw,echo<span class="o">=</span><span class="m">0</span>,isig<span class="o">=</span><span class="m">1</span> UNIX:monitor.sock
</pre></div>
</div>
<ul class="simple">
<li><p>connect to QEmu guest console for example with:</p></li>
</ul>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>socat STDIO,cfmakeraw UNIX:console.sock

<span class="c1"># or, with socat&lt;1.7.3.0</span>
socat STDIO,raw,echo<span class="o">=</span><span class="m">0</span> UNIX:console.sock
</pre></div>
</div>
</div>
<div class="section" id="other-qemu-options">
<h2>Other QEmu options<a class="headerlink" href="#other-qemu-options" title="Permalink to this headline">¶</a></h2>
<p>Here are some options which may be useful when invoking QEmu:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-cpu</span> <span class="pre">kvm64</span></code>: use KVM virtual CPU, not the one of the host.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-machine</span> <span class="pre">accel=kvm</span></code>: use KVM for acceleration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-rtc</span> <span class="pre">base=localtime</span></code>: use localtime for the emulated hardware clock.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-nographic</span> <span class="pre">-serial</span> <span class="pre">stdio</span> <span class="pre">-display</span> <span class="pre">none</span> <span class="pre">-monitor</span> <span class="pre">null</span></code>: output the console
of the guest on the standard output of the terminal which is used to launch
QEmu.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-chardev</span> <span class="pre">stdio,id=stdio,mux=on</span> <span class="pre">-device</span> <span class="pre">virtio-serial</span> <span class="pre">-device</span> <span class="pre">virtserialport,chardev=stdio,name=qemu.stdio</span></code>:
Create a virtual device in the guest, <code class="docutils literal notranslate"><span class="pre">/dev/virtio-ports/qemu.stdio</span></code>, which
can be used to read and write messages to the input and output stream of the
QEmu process.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-chardev</span> <span class="pre">stdio,id=stdio,mux=on,signal=off</span> <span class="pre">-device</span> <span class="pre">virtio-serial-pci</span> <span class="pre">-device</span> <span class="pre">virtconsole,chardev=stdio</span> <span class="pre">-mon</span> <span class="pre">chardev=stdio</span></code>:
Multiplex the console and the monitor on stdio (<code class="docutils literal notranslate"><span class="pre">Ctrl-A</span> <span class="pre">h</span></code> for help)</p></li>
</ul>
</div>
<div class="section" id="qemu-static-chroot">
<h2>QEmu-static chroot<a class="headerlink" href="#qemu-static-chroot" title="Permalink to this headline">¶</a></h2>
<p>To run programs from a foreign CPU architecture without building a virtual
machine, it is possible to setup a chroot environment with QEmu emulation.</p>
<p>For this, the <code class="docutils literal notranslate"><span class="pre">qemu-user-static</span></code> binaries are needed
(<a class="reference external" href="https://packages.debian.org/sid/qemu-user-static">https://packages.debian.org/sid/qemu-user-static</a>).  Then <code class="docutils literal notranslate"><span class="pre">binfmt</span></code> needs to
be configured so that Linux launches these programs when trying to execute
binaries for foreign architectures.</p>
<p>For example, for ARM ELF binaries, this can be done by writing this in
<code class="docutils literal notranslate"><span class="pre">/etc/binfmt.d/qemu-arm.conf</span></code>, on one line:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>:arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:
\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:
/usr/bin/qemu-arm-static:C
</pre></div>
</div>
<p>or by writing this directly into <code class="docutils literal notranslate"><span class="pre">/proc/sys/fs/binfmt_misc/register</span></code>.  If
this succeeds, <code class="docutils literal notranslate"><span class="pre">/proc/sys/fs/binfmt_misc/arm</span></code> file would have been created
with the following content:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>enabled
interpreter /usr/bin/qemu-arm-static
flags: OC
offset 0
magic 7f454c4601010100000000000000000002002800
mask ffffffffffffff00fffffffffffffffffeffffff
</pre></div>
</div>
<p>Once this is configured, an ARM QEmu-static chroot can be built by:</p>
<ul class="simple">
<li><p>creating a base chroot (with <code class="docutils literal notranslate"><span class="pre">debootstrap</span></code> for Debian, <code class="docutils literal notranslate"><span class="pre">pacstrap</span></code> for
Arch Linux), and</p></li>
<li><p>copying <code class="docutils literal notranslate"><span class="pre">/usr/bin/qemu-arm-static</span></code> in the <code class="docutils literal notranslate"><span class="pre">/usr/bin</span></code> directory of the
chroot.</p></li>
</ul>
<p>On debian, there also exists command <code class="docutils literal notranslate"><span class="pre">qemu-debootstrap</span></code>:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>apt-get install qemu qemu-user-static qemu-utils binfmt-support debootstrap

<span class="c1"># arm64 for ARMv8</span>
qemu-debootstrap --arch<span class="o">=</span>arm64 sid /opt/arm64/ http://ftp.debian.org/debian

<span class="c1"># armhf for ARMv7 (hardware floating-point)</span>
qemu-debootstrap --arch<span class="o">=</span>armhf sid /opt/armhf/ http://ftp.debian.org/debian

<span class="c1"># armel for ARMv4 (software floating-point, Little Endian)</span>
qemu-debootstrap --arch<span class="o">=</span>armel sid /opt/armel/ http://ftp.debian.org/debian
</pre></div>
</div>
<p>This allows using usual programs but some have some issues running with
<code class="docutils literal notranslate"><span class="pre">qemu-user-static</span></code>, like <code class="docutils literal notranslate"><span class="pre">strace</span></code> because the <code class="docutils literal notranslate"><span class="pre">ptrace</span></code> syscall is not
implemented.  Nevertheless <code class="docutils literal notranslate"><span class="pre">qemu-user-static</span></code> has an option to show the
system calls which are emulated, so a simple work-around consists in creating
a <code class="docutils literal notranslate"><span class="pre">strace</span></code> shell script for example in <code class="docutils literal notranslate"><span class="pre">/usr/local/bin</span></code> in the chroot with:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="nb">exec</span> qemu-arm-static -strace <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="libvirt-integration">
<h2>Libvirt integration<a class="headerlink" href="#libvirt-integration" title="Permalink to this headline">¶</a></h2>
<p>Libvirt can be used to managed virtual machines. Some commands:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># List all known virtual machines (domains)</span>
<span class="c1"># This command may need to be run as root</span>
virsh list --all

<span class="c1"># Edit the XML configuration of a domain</span>
virsh edit &lt;domain&gt;

<span class="c1"># Start a domain</span>
virsh start &lt;domain&gt;
</pre></div>
</div>
<p>virt-manager can also be used as a graphical interface to interact with virtual
machines (by default in <code class="docutils literal notranslate"><span class="pre">qemu://system</span></code> connection).</p>
<p>When starting, libvirt sets up a network bridge, <code class="docutils literal notranslate"><span class="pre">virbr0</span></code>, with an associated
dnsmasq process to attribute IP addresses. This default network is configured
with <code class="docutils literal notranslate"><span class="pre">virsh</span> <span class="pre">net-edit</span> <span class="pre">default</span></code>. It looks like:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;network&gt;</span>
  <span class="nt">&lt;name&gt;</span>default<span class="nt">&lt;/name&gt;</span>
  <span class="nt">&lt;uuid&gt;</span>bb24f0ba-754c-4f00-b16b-5e7dbb35807e<span class="nt">&lt;/uuid&gt;</span>
  <span class="nt">&lt;forward</span> <span class="na">mode=</span><span class="s">&#39;nat&#39;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;bridge</span> <span class="na">name=</span><span class="s">&#39;virbr0&#39;</span> <span class="na">stp=</span><span class="s">&#39;on&#39;</span> <span class="na">delay=</span><span class="s">&#39;0&#39;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;mac</span> <span class="na">address=</span><span class="s">&#39;52:54:00:12:34:56&#39;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;ip</span> <span class="na">address=</span><span class="s">&#39;192.168.122.1&#39;</span> <span class="na">netmask=</span><span class="s">&#39;255.255.255.0&#39;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dhcp&gt;</span>
      <span class="nt">&lt;range</span> <span class="na">start=</span><span class="s">&#39;192.168.122.2&#39;</span> <span class="na">end=</span><span class="s">&#39;192.168.122.254&#39;</span><span class="nt">/&gt;</span>
      <span class="c">&lt;!-- Static IP addresses --&gt;</span>
      <span class="nt">&lt;host</span> <span class="na">mac=</span><span class="s">&#39;52:54:00:11:22:33&#39;</span> <span class="na">name=</span><span class="s">&#39;vm1&#39;</span> <span class="na">ip=</span><span class="s">&#39;192.168.122.11&#39;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/dhcp&gt;</span>
  <span class="nt">&lt;/ip&gt;</span>
<span class="nt">&lt;/network&gt;</span>
</pre></div>
</div>
<p>The generated dnsmasq configuration is in <code class="docutils literal notranslate"><span class="pre">/var/lib/libvirt/dnsmasq/default.conf</span></code>.</p>
</div>
<div class="section" id="web-links">
<h2>Web links<a class="headerlink" href="#web-links" title="Permalink to this headline">¶</a></h2>
<p>Here are some links to online articles and documentation relevant with QEmu:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://wiki.qemu.org/Testing">http://wiki.qemu.org/Testing</a> QEmu testing images</p></li>
<li><p><a class="reference external" href="https://wiki.archlinux.org/index.php/QEMU">https://wiki.archlinux.org/index.php/QEMU</a> ArchLinux wiki entry</p></li>
<li><dl class="simple">
<dt><a class="reference external" href="http://debian-handbook.info/browse/stable/sect.virtualization.html">http://debian-handbook.info/browse/stable/sect.virtualization.html</a></dt><dd><p>Virtualization – The Debian Administrator’s Handbook</p>
</dd>
</dl>
</li>
<li><p><a class="reference external" href="https://blog.nelhage.com/2013/12/lightweight-linux-kernel-development-with-kvm/">https://blog.nelhage.com/2013/12/lightweight-linux-kernel-development-with-kvm/</a></p></li>
<li><p><a class="reference external" href="http://blog.oddbit.com/2014/07/21/tracking-down-a-kernel-bug-wit/">http://blog.oddbit.com/2014/07/21/tracking-down-a-kernel-bug-wit/</a></p></li>
<li><p><a class="reference external" href="https://www.berrange.com/posts/2011/06/07/what-benefits-does-libvirt-offer-to-developers-targetting-qemukvm/">https://www.berrange.com/posts/2011/06/07/what-benefits-does-libvirt-offer-to-developers-targetting-qemukvm/</a>
(This article explains what libvirt does)</p></li>
<li><p><a class="reference external" href="https://wiki.debian.org/QemuUserEmulation">https://wiki.debian.org/QemuUserEmulation</a>
How to setup and use QEMU user emulation in a “transparent” fashion</p></li>
<li><p><a class="reference external" href="https://github.com/ixty/xarch_shellcode/blob/master/README.md">https://github.com/ixty/xarch_shellcode/blob/master/README.md</a>
Build portable, architecture independent shellcode from C code</p></li>
</ul>
</div>
<div class="section" id="a-quick-glance-at-docker">
<h2>A quick glance at Docker<a class="headerlink" href="#a-quick-glance-at-docker" title="Permalink to this headline">¶</a></h2>
<p>Docker is known for being able to run containers. It is also good for spawning
short-lived well-controlled environment like a fresh Ubuntu Precise (12.04 LTS)
install:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>docker run -t -i ubuntu:12.04 /bin/bash
</pre></div>
</div>
<p>To list images:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>docker images
</pre></div>
</div>
<p>To list containers:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>docker ps -l
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QEmu-KVM notes</a><ul>
<li><a class="reference internal" href="#simple-qemu-invocation-commands">Simple QEmu invocation commands</a></li>
<li><a class="reference internal" href="#networking">Networking</a></li>
<li><a class="reference internal" href="#qcow2-format-and-virtual-disk-usage">QCow2 format and virtual disk usage</a></li>
<li><a class="reference internal" href="#nfs-configuration">NFS configuration</a></li>
<li><a class="reference internal" href="#p-shared-directory">9p shared directory</a></li>
<li><a class="reference internal" href="#interaction-based-on-unix-sockets">Interaction based on Unix sockets</a></li>
<li><a class="reference internal" href="#other-qemu-options">Other QEmu options</a></li>
<li><a class="reference internal" href="#qemu-static-chroot">QEmu-static chroot</a></li>
<li><a class="reference internal" href="#libvirt-integration">Libvirt integration</a></li>
<li><a class="reference internal" href="#web-links">Web links</a></li>
<li><a class="reference internal" href="#a-quick-glance-at-docker">A quick glance at Docker</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pxe-boot-server.html"
                        title="previous chapter">Configure a server to handle network boot (PXE)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="qubes-os.html"
                        title="next chapter">Qubes OS setup</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/sysadmin/qemu.rst.txt"
           rel="nofollow">Show Source</a></li>
    <li><a href="https://github.com/fishilico/generic-config/blob/master/sysadmin/qemu.rst"
           rel="nofollow">Show Source on GitHub
           <img src="../_static/GitHub-Mark-32px.png" style="width: 1.5em; border: none;" alt="" />
           </a></li>
  </ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="qubes-os.html" title="Qubes OS setup"
             >next</a> |</li>
        <li class="right" >
          <a href="pxe-boot-server.html" title="Configure a server to handle network boot (PXE)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Generic Config</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Some notes and tips&amp;tricks about system administration</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2019, Nicolas Iooss.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>